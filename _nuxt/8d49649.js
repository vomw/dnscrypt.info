(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{316:function(e,n,t){var content=t(347);content.__esModule&&(content=content.default),"string"==typeof content&&(content=[[e.i,content,""]]),content.locals&&(e.exports=content.locals);(0,t(64).default)("48c91c8e",content,!0,{sourceMap:!1})},346:function(e,n,t){"use strict";t(316)},347:function(e,n,t){var r=t(63)(function(i){return i[1]});r.push([e.i,'.protocol-page[data-v-17c91e50]{padding-bottom:3rem}.page-header[data-v-17c91e50]{margin-bottom:3rem;text-align:center}.page-header h1[data-v-17c91e50]{color:#1a202c;font-size:2.5rem;font-weight:700;margin:0 0 1rem}.page-header p[data-v-17c91e50]{color:#718096;font-size:1.15rem;margin:0}.protocol-card[data-v-17c91e50]{border:none!important;border-radius:16px!important;box-shadow:0 4px 20px rgba(0,0,0,.08)!important;overflow:hidden}.protocol-card .v-card__text[data-v-17c91e50]{padding:0!important}.protocol-text[data-v-17c91e50]{background:#1a202c!important;border-radius:0;color:#e2e8f0;font-family:"Roboto Mono","Consolas","Monaco",monospace;font-size:.875rem;line-height:1.7;margin:0;overflow-x:auto;padding:2rem;white-space:pre-wrap;word-wrap:break-word}',""]),r.locals={},e.exports=r},362:function(e,n,t){"use strict";t.r(n);var r={head:function(){return{title:"DNSCrypt Protocol Specification Version 2",meta:[{hid:"description",name:"description",content:"Complete technical specification of the DNSCrypt protocol version 2. Learn about the cryptographic DNS encryption protocol designed for secure DNS communication."},{hid:"og:title",property:"og:title",content:"DNSCrypt Protocol Specification Version 2 | DNSCrypt"},{hid:"og:description",property:"og:description",content:"Complete technical specification of the DNSCrypt protocol version 2. Learn about the cryptographic DNS encryption protocol designed for secure DNS communication."},{hid:"og:url",property:"og:url",content:"https://dnscrypt.info/protocol"},{hid:"twitter:title",name:"twitter:title",content:"DNSCrypt Protocol Specification Version 2 | DNSCrypt"},{hid:"twitter:description",name:"twitter:description",content:"Complete technical specification of the DNSCrypt protocol version 2. Learn about the cryptographic DNS encryption protocol."}],link:[{rel:"canonical",href:"https://dnscrypt.info/protocol"}]}},data:function(){return{ProtoText:"\nDNSCrypt version 2 protocol specification\n=========================================\n\n1. Protocol overview\n--------------------\n\nThe DNSCrypt protocol can use the UDP and TCP transport protocols.\nDNSCrypt Clients and resolvers should support the protocol over UDP\nand must support it over TCP.\n\nThe default port for this protocol should be 443, both for TCP and UDP.\n\nBoth the client and the resolver initially generate a short-term key\npair for each supported encryption system.\n\nFrom a client perspective, a DNSCrypt session begins with the client\nsending a non-authenticated DNS query to a DNSCrypt-enabled resolver.\nThis DNS query encodes the certificate versions supported by the\nclient, as well as a public identifier of the provider requested by\nthe client.\n\nThe resolver responds with a public set of signed certificates, that\nmust be verified by the client using a previously distributed public\nkey, known as the provider public key.\n\nEach certificate includes a validity period, a serial number, a\nversion that defines a key exchange mechanism, an authenticated\nencryption algorithm and its parameters, as well as a short-term\npublic key, known as the resolver public key.\n\nA resolver can support multiple algorithms and advertise multiple\nresolver public keys simultaneously. The client picks the one with the\nhighest serial number among the currently valid ones that match a\nsupported protocol version.\n\nEach certificate includes a magic number that the client must prefix its\nqueries with, in order for the resolver to know what certificate was\nchosen by the client to construct a given query.\n\nThe encryption algorithm, resolver public key and client magic number\nfrom the chosen certificate are then used by the client to send\nencrypted queries. These queries include the client public key.\n\nUsing this client public key, and knowing which certificate was chosen\nby the client as well as the relevant secret key, the resolver\nverifies and decrypts the query, and encrypts the response using the\nsame parameters.\n\n2. Common definitions for client queries\n----------------------------------------\n\n<dnscrypt-query> ::= <client-magic> <client-pk> <client-nonce> <encrypted-query>\n\n<client-magic> ::= a 8 byte identifier for the resolver certificate\nchosen by the client.\n\n<client-pk> ::= the client's public key, whose length depends on the\nencryption algorithm defined in the chosen certificate.\n\n<client-sk> ::= the client's secret key.\n\n<resolver-pk> ::= the resolver's public key.\n\n<client-nonce> ::= a unique query identifier for a given\n(<client-sk>, <resolver-pk>) tuple. The same query sent twice for the same\n(<client-sk>, <resolver-pk>) tuple must use two distinct <client-nonce>\nvalues. The length of <client-nonce> depends on the chosen encryption\nalgorithm.\n\n<encrypted-query> ::= AE(<shared-key> <client-nonce> <client-nonce-pad>,\n                         <client-query> <client-query-pad>)\n\nAE ::= the authenticated encryption algorithm.\n\n<shared-key> ::= the shared key derived from <resolver-pk> and\n<client-sk>, using the key exchange algorithm defined in the chosen\ncertificate.\n\n<client-query> ::= the unencrypted client query. The query is not\nmodified; in particular, the query flags are not altered and the query\nlength must be kept in queries prepared to be sent over TCP.\n\n<client-nonce-pad> ::= <client-nonce> length is half the nonce length\nrequired by the encryption algorithm. In client queries, the other half,\n<client-nonce-pad> is filled with NUL bytes.\n\n<client-query-pad> ::= variable-length padding.\n\n3. Padding for client queries over UDP\n--------------------------------------\n\nPrior to encryption, queries are padded using the ISO/IEC 7816-4\nformat. The padding starts with a byte valued 0x80 followed by a\nvariable number of NUL bytes.\n\n<client-query> <client-query-pad> must be at least <min-query-len>\nbytes. If the length of the client query is less than <min-query-len>,\nthe padding length must be adjusted in order to satisfy this\nrequirement.\n\n<min-query-len> is a variable length, initially set to 256 bytes, and\nmust be a multiple of 64 bytes.\n\n4. Client queries over UDP\n--------------------------\n\nClient queries sent using UDP must be padded as described in section 3.\n\nA UDP packet can contain a single query, whose entire content is\nthe <dnscrypt-query> construction documented in section 2.\n\nUDP packets using the DNSCrypt protocol can be fragmented into\nmultiple IP packets and can use a single source port.\n\nAfter having received a query, the resolver can either ignore the query\nor reply with a DNSCrypt-encapsulated response.\n\nThe client must verify and decrypt the response using the resolver's\npublic key, the shared secret and the received nonce. If the response\ncannot be verified, the response must be discarded.\n\nIf the response has the TC flag set, the client must:\n1) send the query again using TCP\n2) set the new minimum query length as:\n\n    <min-query-len> ::= min(<min-query-len> + 64, <max-query-len>)\n\n<min-query-len> must be capped so that the full length of a DNSCrypt\npacket doesn't exceed the maximum size required by the transport layer.\n\nThe client may decrease <min-query-len>, but the length must remain a multiple\nof 64 bytes.\n\n5. Padding for client queries over TCP\n--------------------------------------\n\nPrior to encryption, queries are padded using the ISO/IEC 7816-4\nformat. The padding starts with a byte valued 0x80 followed by a\nvariable number of NUL bytes.\n\nThe length of <client-query-pad> is randomly chosen between 1 and 256\nbytes (including the leading 0x80), but the total length of <client-query>\n<client-query-pad> must be a multiple of 64 bytes.\n\nFor example, an originally unpadded 56-bytes DNS query can be padded as:\n\n<56-bytes-query> 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00\nor\n<56-bytes-query> 0x80 (0x00 * 71)\nor\n<56-bytes-query> 0x80 (0x00 * 135)\nor\n<56-bytes-query> 0x80 (0x00 * 199)\n\n6. Client queries over TCP\n--------------------------\n\nEncrypted client queries over TCP only differ from queries sent over UDP by the\npadding length computation and by the fact that they are prefixed with\ntheir length, encoded as two big-endian bytes.\n\nCleartext DNS query payloads are not prefixed by their length, \neven when sent over TCP.  \n\nUnlike UDP queries, a query sent over TCP can be shorter than the\nresponse.\n\nAfter having received a response from the resolver, the client and the\nresolver must close the TCP connection. Multiple transactions over the\nsame TCP connections are not allowed by this revision of the protocol.\n\n7. Common definitions for resolver responses\n--------------------------------------------\n\n<dnscrypt-response> ::= <resolver-magic> <nonce> <encrypted-response>\n\n<resolver-magic> ::= 0x72 0x36 0x66 0x6e 0x76 0x57 0x6a 0x38\n\n<nonce> ::= <client-nonce> <resolver-nonce>\n\n<client-nonce> ::= the nonce sent by the client in the related query.\n\n<client-pk> ::= the client's public key.\n\n<resolver-sk> ::= the resolver's secret key.\n\n<resolver-nonce> ::= a unique response identifier for a given\n(<client-pk>, <resolver-sk>) tuple. The length of <resolver-nonce>\ndepends on the chosen encryption algorithm.\n\n<encrypted-response> ::= AE(<shared-key>, <nonce>,\n                            <resolver-response> <resolver-response-pad>)\n\nAE ::= the authenticated encryption algorithm.\n\n<shared-key> ::= the shared key derived from <resolver-sk> and\n<client-pk>, using the key exchange algorithm defined in the chosen\ncertificate.\n\n<resolver-response> ::= the unencrypted resolver response. The\nresponse is not modified; in particular, the query flags are not\naltered and the response length must be kept in responses prepared to\nbe sent over TCP.\n\n<resolver-response-pad> ::= variable-length padding.\n\n8. Padding for resolver responses\n---------------------------------\n\nPrior to encryption, responses are padded using the ISO/IEC 7816-4\nformat. The padding starts with a byte valued 0x80 followed by a\nvariable number of NUL bytes.\n\nThe total length of <resolver-response> <resolver-response-pad> must\nbe a multiple of 64 bytes.\n\nThe length of <resolver-response-pad> must be between 1 and 256 bytes\n(including the leading 0x80), and must be constant for one of these\ntuples:\n\n- (<resolver-sk>, <client-nonce>)\n- (<shared-key> , <client-nonce>)\n\nA pseudorandom function can be used to satisfy this requirement.\n\n9. Resolver responses over UDP\n------------------------------\n\nThe resolver must verify and decrypt client queries. Queries that\ncannot be verified must be ignored.\n\nAny client-supplied nonce must be accepted. However, a resolver can\nignore or refuse queries encrypted using untrusted public keys.\n\nResponses must be padded using the algorithm described in section 8\nand encrypted as described in section 7.\n\nIf the full client query length is shorter than 256 bytes, or shorter\nthan the full response length, the resolver may truncate the response\nand set the TC flag prior to encrypting it. The response length should\nalways be equal to or shorter than the initial client query length.\n\n10. Resolver responses over TCP\n-------------------------------\n\nThe resolver must verify and decrypt client queries. Queries that\ncannot be verified must be ignored.\n\nAny client-supplied nonce must be accepted. However, a resolver can\nignore or refuse queries encrypted using untrusted public keys.\n\nResponses must be padded using the algorithm described in section 8,\nencrypted as described in section 7. Encrypted responses are prefixed \nwith their length encoded as two big-endian bytes.\n\nCleartext DNS response payloads are not prefixed by their length, \neven when sent over TCP.  \n\nResponses must be send unmodified even if their length exceeds the\nlength of the client query.\n\n11. Authenticated encryption and key exchange algorithm\n-------------------------------------------------------\n\nThe X25519-XChaCha20Poly1305 construction, and the way to use it\ndescribed in this section, must be referenced in certificates as\nversion 2 of the public-key authenticated encryption system.\n\nThe construction, originally implemented in\nthe libsodium cryptographic library and exposed under the name\n\"crypto_box_xchacha20poly1305\", uses the Curve25119 elliptic curve in\nMontgomery form and the hchacha20 hash function for key exchange,\nthe XChaCha20 stream cipher, and Poly1305 for message authentication.\n\nThe public and secret keys are 32 bytes long in storage. The MAC is 16 bytes\nlong, and is prepended to the ciphertext.\n\nWhen using X25519-XChaCha20Poly1305, this construction requires a 24 bytes\nnonce, that must not be reused for a given shared secret.\n\nWith a 24 bytes nonce, a question sent by a DNSCrypt client must be\nencrypted using the shared secret, and a nonce constructed as follows:\n12 bytes chosen by the client followed by 12 NUL (0) bytes.\n\nA response to this question must be encrypted using the shared secret,\nand a nonce constructed as follows: the bytes originally chosen by\nthe client, followed by bytes chosen by the resolver.\n\nThe resolver's half of the nonce should be randomly chosen.\n\nThe client's half of the nonce can include a timestamp in addition to a\ncounter or to random bytes, so that when a response is received, the\nclient can use this timestamp to immediately discard responses to\nqueries that have been sent too long ago, or dated in the future.\n\n12. Certificates\n----------------\n\nThe client begins a DNSCrypt session by sending a regular unencrypted\nTXT DNS query to the resolver IP address, on the DNSCrypt port, first\nover UDP, then, in case of failure, timeout or truncation, over TCP.\n\nResolvers are not required to serve certificates both on UDP and TCP.\n\nThe name in the question must follow this scheme:\n\n<provider name> ::= <protocol-major-version> . dnscrypt-cert . <zone>\n\nA major protocol version has only one certificate format.\n\nA DNSCrypt client implementing the second version of the protocol must\nsend a query with the TXT type and a name of the form:\n\n2.dnscrypt-cert.example.com\n\nThe zone must be a valid DNS name, but may not be registered in the DNS\nhierarchy.\n\nA single provider name can be shared by multiple resolvers operated by\nthe same entity, and a resolver can respond to multiple provider\nnames, especially to support multiple protocol versions simultaneously.\n\nIn order to use a DNSCrypt-enabled resolver, a client must know the\nfollowing information:\n\n- The resolver IP address and port\n- The provider name\n- The provider public key\n\nThe provider public key is a long-term key whose sole purpose is to\nverify the certificates. It is never used to encrypt or verify DNS queries.\nA unique provider public key can be used to sign multiple certificates.\n\nFor example, an organization operating multiple resolvers can use\na unique provider name and provider public key across all resolvers,\nand just provide a list of IP addresses and ports. Each resolver may\nhave its unique set of certificates that can be signed with the\nsame key.\n\nCertificates should be signed on dedicated hardware and not on the\nresolvers. Resolvers must serve the certificates, provided that they\nhave already been signed.\n\nA successful response to certificate request contains one or more TXT\nrecords, each record containing a certificate encoded as follows:\n\n<cert> ::= <cert-magic> <es-version> <protocol-minor-version> <signature>\n           <resolver-pk> <client-magic> <serial> <ts-start> <ts-end>\n           <extensions>\n\n<cert-magic> ::= 0x44 0x4e 0x53 0x43\n\n<es-version> ::= the cryptographic construction to use with this\ncertificate.\nFor X25519-XChacha20Poly1305, <es-version> must be 0x00 0x02.\n\n<protocol-minor-version> ::= 0x00 0x00\n\n<signature> ::= a 64-byte signature of (<resolver-pk> <client-magic>\n<serial> <ts-start> <ts-end> <extensions>) using the Ed25519 algorithm and the\nprovider secret key. Ed25519 must be used in this version of the\nprotocol.\n\n<resolver-pk> ::= the resolver short-term public key, which is 32 bytes when\nusing X25519.\n\n<client-magic> ::= the first 8 bytes of a client query that was built\nusing the information from this certificate. It may be a truncated\npublic key. Two valid certificates cannot share the same <client-magic>.\n\n<client-magic> must not start with 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n(seven all-zero bytes) in order to avoid a confusion with the QUIC protocol.\n\n<serial> ::= a 4 byte serial number in big-endian format. If more than\none certificates are valid, the client must prefer the certificate\nwith a higher serial number.\n\n<ts-start> ::= the date the certificate is valid from, as a big-endian\n4-byte unsigned Unix timestamp.\n\n<ts-end> ::= the date the certificate is valid until (inclusive), as a\nbig-endian 4-byte unsigned Unix timestamp.\n\n<extensions> ::= empty in the current protocol version, but may\ncontain additional data in future revisions, including minor versions.\nThe computation and the verification of the signature must include the\nextensions. An implementation not supporting these extensions must\nignore them.\n\nCertificates made of these information, without extensions, are 116 bytes\nlong. With the addition of the cert-magic, es-version and\nprotocol-minor-version, the record is 124 bytes long.\n\nAfter having received a set of certificates, the client checks their\nvalidity based on the current date, filters out the ones designed for\nencryption systems that are not supported by the client, and chooses\nthe certificate with the higher serial number.\n\nDNSCrypt queries sent by the client must use the <client-magic>\nheader of the chosen certificate, as well as the specified encryption\nsystem and public key.\n\nThe client must check for new certificates every hour, and switch to a\nnew certificate if:\n- the current certificate is not present or not valid any more\nor\n- a certificate with a higher serial number than the current one is\navailable.\n\n13. Operational considerations\n------------------------------\n\nSpecial attention should be paid to the uniqueness of the generated\nsecret keys.\n\nClient public keys can be used by resolvers to authenticate clients,\nlink queries to customer accounts, and unlock business-specific\nfeatures such as redirecting specific domain names to a sinkhole.\n\nResolvers accessible from any client IP address can also opt for only\nresponding to a set of whitelisted public keys.\n\nResolvers accepting queries from any client must accept any client\npublic key. In particular, an anonymous client can generate a new key pair\nfor every session, or even for every query. This mitigates the ability\nfor a resolver to group queries by client public keys, and discover\nthe set of IP addresses a user might have been operating.\n\nResolvers must rotate the short-term key pair every 24 hours at most, and\nmust throw away the previous secret key.\n\nDuring a key rotation, and provided that the old key hasn't been\ncompromised, a resolver should accept both the old and the new key for at\nleast 4 hours, and public them as different certificates.\n\nProvider public keys may be published as a DNSSEC-signed TXT records,\nin the same zone as the provider name.\n\nFor example, a query for the TXT type on the name \"2.pubkey.example.com\"\nmay return a signed record containing a hexadecimal-encoded provider\npublic key for the provider name \"2.dnscrypt-cert.example.com\".\n\nWhile authenticated and unauthenticated queries can share the same\nresolver TCP and/or UDP port, this should be avoided. Client magic\nnumbers do not completely prevent collisions with legitimate unauthenticated\nDNS queries. In addition, DNSCrypt offers some mitigation against\nabusing resolvers to conduct DDoS attacks. Accepting unauthenticated\nqueries on the same port would defeat this mechanism.\n\nAs a client is likely to reuse the same key pair many times, servers are\nencouraged to cache shared keys instead of performing the X25519\noperation for each query. This makes the computational overhead of\nDNSCrypt negligible compared to plain DNS.\n\n14. Implementations\n-------------------\n\nKnown open source implementations of the DNSCrypt version 2 protocol are:\n\n- Encrypted DNS Server - server-side implementation in Rust\n- PowerDNS dnsdist - a DNS loadbalancer that provides server-side DNSCrypt\n- unbound - a validating, caching resolver that provides server-side DNSCrypt\n- dnscrypt-proxy - client-side implementation in Go\n- pcap_dnsproxy - client-side implementation in C++\n- dnscrypt-python - client-side implementation in Python\n- dnspython-dnscrypt - client-side implementation in Python\n- YourFriendlyDNS - client-side implementation in C++\n- Adguard - client-side and server-side implementations in Go\n- reklatsmasters/dnscrypt - client implementation in pure JavaScript\n- Texnomic SecureDNS - server implementation in C#\n\n15. Contributing\n----------------\n\nThe repository for this document and related documents is:\nhttps://github.com:DNSCrypt/dnscrypt-protocol\n\nContributions can be made by creating pull requests.\n\nThe GitHub interface supports creating pull requests using the Edit (‚úè) button."}}},o=(t(346),t(31)),component=Object(o.a)(r,function(){var e=this,n=e._self._c;return n("div",{staticClass:"protocol-page"},[e._m(0),e._v(" "),n("v-card",{staticClass:"protocol-card"},[n("v-card-text",[n("pre",{staticClass:"protocol-text"},[e._v(e._s(e.ProtoText))])])],1)],1)},[function(){var e=this,n=e._self._c;return n("div",{staticClass:"page-header"},[n("h1",[e._v("Protocol Specification")]),e._v(" "),n("p",[e._v("Complete technical specification of the DNSCrypt protocol version 2.")])])}],!1,null,"17c91e50",null);n.default=component.exports}}]);